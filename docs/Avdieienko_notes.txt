================================================================
ТЕКСТ ДО СЛАЙДІВ ТА ВІДПОВІДІ НА ПИТАННЯ
Тема: «K в ряд (падіння)»
Автор: Авдєєнко Дмитро Максимович
================================================================

────────────────────────────────────────────────────────────────
СЛАЙД 1 — ТИТУЛЬНИЙ
────────────────────────────────────────────────────────────────
До вашої уваги доповідь на тему «K в ряд (падіння)».
Доповідає Авдєєнко Дмитро Максимович.

Автором реалізовано логічну гру — аналог Connect 4 — засобами
логічного програмування Prolog. Вся ігрова логіка залишається
справжнім Prolog-кодом: перевірка виграшу, мінімакс з
Alpha-Beta відсіканням. Веб-інтерфейс доступний без
встановлення будь-якого програмного забезпечення.

────────────────────────────────────────────────────────────────
СЛАЙД 2 — АНОТАЦІЯ
────────────────────────────────────────────────────────────────
Проєкт демонструє повноцінний веб-додаток, де ігровий інтелект
реалізований виключно засобами Prolog — жодного дублювання логіки
на JavaScript. Підтримуються довільний розмір поля, заборонені
клітини, чотири режими гри та вибір складності.

Головна технічна особливість: два рівні Prolog у єдиній системі —
браузерний (Tau-Prolog для валідації ходів людини) та серверний
(SWI-Prolog для обчислення ходів ШІ). Для порівняння реалізовано
аналог на Haskell.

────────────────────────────────────────────────────────────────
СЛАЙД 3 — ОГЛЯД ІСНУЮЧИХ РІШЕНЬ
────────────────────────────────────────────────────────────────
Більшість відомих реалізацій Connect 4 на Prolog мають консольний
інтерфейс — що суперечить вимозі сучасного веб-інтерфейсу.
Ті, що мають веб-частину, як правило або зберігають стан у
глобальних фактах, або мають слабкий ШІ без Alpha-Beta.

Основна відмінність цієї роботи: стан передається між ходами
через атом JavaScript (рядок), а не через глобальний стан Prolog.
Це дозволяє залишатися без мутації і зробити сервер повністю
stateless.

────────────────────────────────────────────────────────────────
СЛАЙД 3б — РЕЦЕНЗІЯ МИНУЛОРІЧНИХ ВІДЕО
────────────────────────────────────────────────────────────────

ВІДЕО 1 — Марина Чантон:
Авторка чесно зафіксувала, що підключення Prolog до GUI
виявилось найскладнішою частиною роботи. Три різних підходи
зазнали невдачі — переважно через труднощі з відлагодженням
помилок, які виникають на стороні Prolog і погано відображаються
в браузері. Найсильніша версія з MinMax залишилась консольною.

  - Python/Haskell — порівняльні реалізації
  - Tau-Prolog у браузері — MinMax не вдалося зробити достатньо
    швидким, противник слабкий
  - Консольна SWI-Prolog — найповноцінніша, але без GUI
  - Підхід: Tau-Prolog без сервера

ВІДЕО 2 — Prolog + Node.js:
Автор вирішив проблему GUI через Node.js як посередника —
SWI-Prolog викликається shell-командою з JavaScript. Вдалося
реалізувати повний веб-інтерфейс та 3 рівні складності.
Проте MinMax обмежено 4-ма центральними стовпцями для швидкодії,
а частина коду MinMax запозичена з відомих реалізацій.

  - CORS через SWI HTTP Server виявився «нерозв'язною» проблемою
    для автора → обійшли через Node.js
  - MinMax обмежений 4-ма стовпцями (оптимізація продуктивності)
  - Підхід: Node.js + shell exec до SWI-Prolog

Порівняно з обома відео, цей проєкт вирішує CORS безпосередньо
в SWI-Prolog HTTP Server, не потребує посередника, і MinMax
розглядає всі доступні стовпці.

────────────────────────────────────────────────────────────────
СЛАЙД 4 — АРХІТЕКТУРА СИСТЕМИ
────────────────────────────────────────────────────────────────
Система розбита на два незалежних рівні Prolog.

Перший рівень — браузерний: Tau-Prolog 0.3.4 виконується
безпосередньо у вкладці браузера і відповідає виключно за
обробку ходу людини: перевірку доступності стовпця, гравітацію,
перевірку виграшу/нічиєї.

Другий рівень — серверний: SWI-Prolog запущений у Docker-контейнері
на Render.com і отримує POST-запит з поточним станом дошки.
Він обчислює найкращий хід за допомогою MinMax з Alpha-Beta і
повертає результат у форматі JSON.

Стан дошки передається між JavaScript та Prolog у вигляді
плаского рядка символів — без серверного сесійного стану.

────────────────────────────────────────────────────────────────
СЛАЙД 5 — ПРЕДСТАВЛЕННЯ ДОШКИ У PROLOG
────────────────────────────────────────────────────────────────
Усередині Prolog дошка представлена як список рядків, де кожен
рядок — список символів. Такий формат забезпечує доступ до
будь-якої клітини за час O(R+C), що суттєво швидше ніж O(R×C)
для плаского списку.

Між Prolog і JavaScript стан передається як рядок (атом)
довжиною R×C символів: 'e' — порожня, 'x'/'o' — гравці,
'b' — заблокована клітина. Перетворення між форматами виконується
предикатами atom_to_board/3 та board_to_atom/2, які не мають
жодного стану — щоразу будується новий терм.

────────────────────────────────────────────────────────────────
СЛАЙД 6 — ГРАВІТАЦІЯ ТА ДОСТУПНІ ХОДИ
────────────────────────────────────────────────────────────────
Гравітація реалізована через рекурсивний пошук знизу вгору.
Предикат find_bottom проходить стовпець від нижнього рядка до
верхнього і повертає першу порожню клітину. Якщо стовпець
повністю заповнений — предикат завершується збоєм, і хід
вважається недоступним.

Предикат drop_piece/6 є декларативним: він не модифікує дошку,
а породжує новий терм з оновленою клітиною. Це типова
Prolog-ідіома — незмінні структури даних через уніфікацію.

Список доступних стовпців будується з пріоритетом центральних
колонок — це покращує ефективність Alpha-Beta відсікання,
оскільки сильніші ходи розглядаються першими.

────────────────────────────────────────────────────────────────
СЛАЙД 7 — ПЕРЕВІРКА ВИГРАШУ
────────────────────────────────────────────────────────────────
Перевірка виграшу після кожного ходу є потенційно дорогою
операцією. Ключова оптимізація: нова фішка може утворити
виграшну комбінацію лише через ту клітину, де вона приземлилась.
Тому немає потреби сканувати всю дошку — достатньо перевірити
4 напрямки від точки падіння.

Предикат winner/7 приймає координати падіння (Row, Col) і
перевіряє чотири напрямки: горизонтальний, вертикальний та два
діагональних. У кожному напрямку count_dir рекурсивно рахує
однакові фішки в обидва боки. Якщо сума ≥ K — зафіксовано
перемогу. Складність — O(4K) замість O(R×C×4K).

────────────────────────────────────────────────────────────────
СЛАЙД 8 — АЛГОРИТМ MINIMAX
────────────────────────────────────────────────────────────────
MinMax будує дерево всіх можливих продовжень гри на задану
глибину. ШІ (максимізатор) намагається обрати хід з найвищою
оцінкою, суперник (мінімізатор) — з найнижчою.

Глибина вимірюється у пів-ходах: глибина 4 означає 2 повних
ходи кожного з гравців. Зі збільшенням глибини кількість
вузлів зростає експоненційно — тому для практичного використання
застосовується Alpha-Beta відсікання.

У Prolog MinMax природно виражається через рекурсивні клаузи.
Базові випадки — термінальні стани (перемога, нічия, глибина 0)
— записуються першими. Рекурсивний випадок використовує findall
для генерації всіх ходів і вибирає найкращий через обхід з
накопиченням максимуму або мінімуму.

────────────────────────────────────────────────────────────────
СЛАЙД 9 — ALPHA-BETA ВІДСІКАННЯ ТА ВИПРАВЛЕННЯ ПОМИЛКИ
────────────────────────────────────────────────────────────────
Alpha-Beta є оптимізацією MinMax: якщо поточна гілка дерева
вже гірша за раніше знайдений варіант, її можна не розглядати.
Максимізатор підтримує значення α (нижній поріг), мінімізатор —
β (верхній поріг). Відсікання відбувається, коли ці пороги
перетинаються. На практиці це скорочує кількість вузлів на 60–80%.

Під час розробки було виявлено помилку у визначенні термінального
стану. У початковій версії умова перевіряла, чи останній гравець
відрізняється від поточного (LP \= Player) — але ця умова завжди
виконується, бо гравці чергуються. В результаті виграшна позиція
повертала максимальний бал незалежно від того, хто переміг.

Виправлення: замість порівняння гравців використовується прапор
IsMax. Якщо IsMax=false — ШІ щойно зробив хід і отримав +100000
(виграш). Якщо IsMax=true — противник щойно зробив хід і
отримав −100000 (програш ШІ).

────────────────────────────────────────────────────────────────
СЛАЙД 10 — ЕВРИСТИЧНА ОЦІНКА ПОЗИЦІЇ
────────────────────────────────────────────────────────────────
Евристична функція оцінює позицію на листках дерева пошуку —
коли ні виграшу, ні програшу ще немає, але потрібно визначити,
наскільки позиція вигідна.

Алгоритм сканує всі вікна розміром K (по горизонталі, вертикалі
та обох діагоналях). Кожне вікно, яке містить лише фішки ШІ,
дає позитивний бал залежно від кількості заповнених клітин:
1→1, 2→10, 3→100, 4→1000. Вікна, де є фішки обох гравців,
не рахуються. Підсумкова оцінка — різниця балів ШІ та суперника.

────────────────────────────────────────────────────────────────
СЛАЙД 11 — МУЛЬТИПРИЗНАЧЕННІСТЬ ПРЕДИКАТІВ
────────────────────────────────────────────────────────────────
Мультипризначенність — одна з ключових переваг Prolog над
іншими мовами. Завдяки уніфікації один і той самий предикат
може обчислювати результат у прямому напрямку, перевіряти
відповідність або навіть генерувати варіанти через backtracking.

Наприклад, drop_piece при конкретному стовпці знаходить рядок
падіння. Разом з findall він може перебирати всі доступні
стовпці — саме так MinMax генерує гілки дерева без окремого
циклу. Це відрізняє Prolog від Haskell чи Python, де одна
функція зазвичай виконує одну чітко задану роль.

────────────────────────────────────────────────────────────────
СЛАЙД 12 — РЕЖИМИ ГРИ ТА ПАРАМЕТРИ
────────────────────────────────────────────────────────────────
Реалізовано всі чотири режими: людина–людина, людина–Prolog,
Prolog–людина, Prolog–Prolog. В останньому режимі гра
розгортається автоматично — два ШІ роблять ходи по черзі
без участі людини.

Параметри налаштовуються через веб-інтерфейс: розмір поля,
довжина виграшної серії K ∈ {3,4,5}, заборонені клітини,
глибина пошуку (2/4/5/7 пів-ходів).

────────────────────────────────────────────────────────────────
СЛАЙД 13 — ПРОБЛЕМИ ПІД ЧАС РОЗРОБКИ
────────────────────────────────────────────────────────────────
Розробка виявила кілька нетривіальних проблем.

1. Tau-Prolog: обмежена підтримка бібліотек SWI-Prolog,
   синхронна робота блокує UI браузера, складне відлагодження
   без стандартних інструментів. Рішення: перенести ШІ на
   SWI-Prolog сервер, Tau-Prolog лише для валідації ходів.

2. CORS preflight: браузер надсилає OPTIONS-запит перед кожним
   POST. SWI HTTP-сервер за замовчуванням не обробляє OPTIONS →
   відповідь 405 → браузер блокує основний запит. Вирішено
   одним обробником, який перевіряє метод запиту всередині
   тіла предиката і відповідно реагує.

3. Помилка знаку MinMax: умова LP \= Player завжди виконується,
   бо гравці чергуються (детально — слайд 9).

4. sleep(inf) не підтримується в SWI-Prolog 9.2.3 →
   замінено на thread_get_message(_).

5. Render.com cold start: перший запит після простою займає
   до 30–60 секунд через запуск Docker-контейнера.

────────────────────────────────────────────────────────────────
СЛАЙД 14 — ПОРІВНЯННЯ ПІДХОДІВ
────────────────────────────────────────────────────────────────
Усі три реалізації розв'язують одну задачу різними засобами.

Prolog: незмінний терм дошки, уніфікація замість присвоєння,
MinMax через рекурсивні клаузи та findall. Мультипризначенність
вбудована. Приблизно у 5–10 разів повільніший за Python.

Haskell: незмінний record, рекурсивні функції з Maybe,
строга типізація. Мультипризначенності немає. Приблизно у
2–3 рази повільніший за Python.

Python (ілюстративно): масиви з мутацією, явна рекурсія,
найшвидший з трьох.

CLP(FD) не застосовано: MinMax — це пошук у дереві гри, де
немає FD-змінних з обмеженнями. CLP доцільний для задач
розкладів та розподілу ресурсів.

────────────────────────────────────────────────────────────────
СЛАЙД 15 — ДЕМОНСТРАЦІЯ
────────────────────────────────────────────────────────────────
Демонстрація живої гри або відеозапис:
  https://avdieienkodmytro.github.io/Game_Prolog

Варіанти показу:
  - Режим людина–Prolog (глибина 4, ~2 секунди на хід)
  - Режим Prolog–Prolog (автогра, два ШІ)
  - Поле з забороненими клітинами

────────────────────────────────────────────────────────────────
СЛАЙД 16 — ВИСНОВКИ
────────────────────────────────────────────────────────────────
Основний результат: повноцінна логічна гра з веб-інтерфейсом,
де вся ігрова логіка виконується справжнім Prolog-кодом.

Продемонстровано можливість використання SWI-Prolog як
повноцінного HTTP-сервера з CORS у продуктивному середовищі.
Tau-Prolog дозволяє виконувати Prolog-код безпосередньо в
браузері без плагінів.

Alpha-Beta суттєво прискорює пошук: глибина 7 (≈600к вузлів
без відсікання) стає практичною завдяки скороченню до ≈15к вузлів.

────────────────────────────────────────────────────────────────
СЛАЙД 17 — ДЖЕРЕЛА
────────────────────────────────────────────────────────────────
Russell S., Norvig P. Artificial Intelligence: A Modern
Approach, 4th ed., §5 — Adversarial Search and Games.
Основний теоретичний опис MinMax та Alpha-Beta.

SWI-Prolog documentation — https://www.swi-prolog.org/pldoc/
HTTP-сервер, CORS, thread_get_message.

Tau-Prolog — http://tau-prolog.org/

Render.com Docker deployment — https://render.com/docs/docker

════════════════════════════════════════════════════════════════
МОЖЛИВІ ПИТАННЯ ТА ВІДПОВІДІ
════════════════════════════════════════════════════════════════

П: Чому не використали CLP(FD)?
В: MinMax — це пошук у дереві гри, де на кожному кроці
   обирається хід і оцінюється позиція. Змінні ходів не є
   FD-змінними, а пошук ведеться через findall/member.
   CLP(FD) ефективний для задач типу n-queens, розкладів,
   розподілу ресурсів — де є чіткі обмеження на змінні.

П: Чому Tau-Prolog не може виконувати MinMax?
В: Tau-Prolog виконується в JavaScript-потоці браузера і блокує
   UI на час обчислень. MinMax на глибину 5–7 займає секунди —
   за цей час браузер «заморожується». Крім того, Tau-Prolog
   не підтримує більшість SWI-Prolog бібліотек. Тому ШІ
   перенесено на сервер.

П: Що таке stateless сервер? Навіщо?
В: Сервер не зберігає жодної інформації між запитами. Кожен
   POST-запит містить повний стан дошки у вигляді рядка-атому.
   Це дозволяє масштабувати сервер і уникнути проблем з
   ізоляцією ігрових сесій.

П: Як вирішили проблему CORS?
В: OPTIONS-запит (preflight) обробляється тим самим обробником,
   що й POST. Всередині перевіряється метод запиту. Якщо OPTIONS —
   повертаються CORS-заголовки і порожнє тіло. Якщо POST —
   виконується MinMax і повертається JSON.

П: Яка реальна швидкість ШІ?
В: Глибина 4 (нормальна) — близько 2 секунди. Глибина 7 (важка)
   — близько 15 секунд. Перший хід після простою може займати
   до 60 секунд через cold start Render.com.

П: Що таке пів-хід у MinMax?
В: Повний хід — це хід обох гравців. Пів-хід — хід одного.
   Глибина 4 = 2 повних ходи = 4 пів-ходи. Вимірювання у
   пів-ходах дає точний контроль над глибиною пошуку.

П: Чим відрізняється ваш підхід від Відео 2 (Node.js)?
В: Відео 2 використовує Node.js як посередника — викликає
   SWI-Prolog через shell exec(). Тут SWI-Prolog сам є HTTP-сервером
   — запит обробляється безпосередньо Prolog-кодом без посередника.
   Також CORS вирішено нативно, а MinMax розглядає всі стовпці
   (не обмежується 4-ма).

П: Для чого Haskell-реалізація?
В: Для порівняння стилів програмування: Prolog vs функціональна
   мова зі строгою типізацією. Haskell також не має мутації,
   але реалізує MinMax через рекурсивні функції з Maybe, а не
   через уніфікацію і backtracking. Це ілюструє переваги та
   обмеження кожного підходу.
