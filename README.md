# Game\_Prolog — K в ряд (падіння)

- **Автор:** Авдєєнко Дмитро Максимович
- **Курс:** Логічне програмування · SWI-Prolog
- **Демо:** [https://avdieienkodmytro.github.io/Game\_Prolog](https://avdieienkodmytro.github.io/Game_Prolog)
- **Репозиторій:** [https://github.com/AvdieienkoDmytro/Game\_Prolog](https://github.com/AvdieienkoDmytro/Game_Prolog)

---

## Опис проєкту

Логічна гра **"K в ряд"** з гравітаційною механікою (аналог Connect 4).

- Поле **n×m** (n ≥ 5, m ≥ 6), K ∈ {3, 4, 5}
- Фішки **падають** до нижнього вільного рядка стовпця (гравітація)
- Підтримуються **заборонені клітини** — перешкоди на полі
- ШІ на основі **MinMax + Alpha-Beta відсікання**

### Архітектура

```
GitHub Pages (статичний хост)
    └── index.html
          ├── Tau-Prolog 0.3.4 (в браузері)
          │     ├── js_human/9  — хід людини + перевірка виграшу
          │     └── js_new_board/4 — ініціалізація поля
          └── fetch() → Render.com (Docker/SWI-Prolog)
                └── POST /ai → MinMax + Alpha-Beta (Prolog)
```

Вся ігрова логіка (MinMax, Alpha-Beta, перевірка виграшу) реалізована в **справжньому Prolog-коді**:
- **Tau-Prolog** виконується в браузері — валідація ходів людини
- **SWI-Prolog** на Render.com — обчислення ходів ШІ

---

## Анотація

Реалізовано повноцінну логічну гру «K в ряд» з гравітаційною механікою (аналог Connect 4) та штучним інтелектом на основі MinMax з Alpha-Beta відсіканням. Вся ігрова логіка — перевірка виграшу, гравітація, MinMax — виконується справжнім Prolog-кодом, а не JavaScript.

Для цього задіяно два Prolog-середовища одночасно: **Tau-Prolog 0.3.4** виконується безпосередньо у браузері та відповідає за обробку ходів людини без звернення до сервера; **SWI-Prolog** розгорнутий у Docker-контейнері на Render.com і обробляє HTTP POST-запити з поточним станом дошки, повертаючи найкращий хід ШІ. Стан дошки зберігається на боці JavaScript як плаский рядок символів — Prolog залишається stateless між запитами.

У роботі показано, що SWI-Prolog може служити повноцінним REST-сервером з підтримкою CORS, а Prolog-код природно виражає ігрові алгоритми через рекурсивні клаузи, backtracking і мультипризначенність предикатів. Для порівняння реалізовано аналог на Haskell, що ілюструє відмінності між декларативними підходами.

---

## Структура репозиторію

```
Game_Prolog/
├── index.html              # Веб-інтерфейс (GitHub Pages)
├── web/
│   └── index.html          # Альтернативна сторінка
├── src/
│   ├── prolog/
│   │   ├── kinariad.pl     # Основний SWI-Prolog рушій (локальний запуск)
│   │   └── kinariad_tau.pl # Tau-Prolog адаптація (браузер)
│   └── haskell/
│       └── KInARow.hs      # Порівняльна реалізація на Haskell
├── server/
│   ├── server.pl           # SWI-Prolog HTTP-сервер (MinMax + Alpha-Beta)
│   └── Dockerfile          # Docker для розгортання на Render.com
├── docs/
│   └── (презентація, нотатки)
└── README.md
```

---

## Режими гри

| Режим | X | O |
|-------|---|---|
| Людина – Людина | Гравець | Гравець |
| Людина – Prolog | Гравець | ШІ (SWI-Prolog) |
| Prolog – Людина | ШІ (SWI-Prolog) | Гравець |
| Prolog – Prolog | ШІ (SWI-Prolog) | ШІ (SWI-Prolog) |

---

## Локальний запуск (SWI-Prolog)

```prolog
?- [src/prolog/kinariad].

% Нова гра 6x7, k=4
?- new_game(6, 7, 4, [], B), print_board(B).

% Хід людини
?- new_game(6, 7, 4, [], B0),
   human_move(B0, 4, x, B1),
   print_board(B1).

% Хід ШІ (глибина 6 пів-ходів)
?- new_game(6, 7, 4, [], B0),
   prolog_move(B0, x, 6, B1, Col),
   format("ШІ -> стовпець ~w~n", [Col]),
   print_board(B1).

% Із забороненими клітинами
?- new_game(6, 7, 4, [(3,3),(3,4)], B), print_board(B).
```

---

## Ключові предикати

### kinariad.pl (SWI-Prolog, локальний рушій)

| Предикат | Індикатори | Призначення |
|----------|-----------|-------------|
| `new_game/5` | `++,++,++,++,--` | Створення дошки |
| `drop_piece/5` | `++,++,++,--,--` | Падіння фішки (гравітація) |
| `col_available/2` | `++,++` | Перевірка доступності стовпця |
| `winner/4` | `++,++,++,--` | Перевірка виграшу після ходу |
| `minimax/7` | `++,++,++,++,++,++,--` | MinMax + Alpha-Beta |
| `best_move/4` | `++,++,++,--` | Вибір ходу ШІ |

### server.pl (SWI-Prolog HTTP-сервер)

| Предикат | Призначення |
|----------|-------------|
| `js_ai/10` | Точка входу: BoardAtom → MinMax → відповідь |
| `winner/7` | Перевірка виграшу в точці падіння |
| `eval_board/4` | Евристична оцінка позиції |
| `minimax/13` | MinMax + Alpha-Beta (row-list board) |
| `best_move/7` | Вибір найкращого стовпця |

### kinariad_tau.pl (Tau-Prolog, браузер)

| Предикат | Призначення |
|----------|-------------|
| `js_human/9` | Хід людини + win/draw/full/ok |
| `js_new_board/4` | Ініціалізація поля |
| `available_cols/3` | Список доступних стовпців (center-first) |

---

## Alpha-Beta: глибина у пів-ходах

Параметр `Depth` — кількість **пів-ходів** (не повних ходів):

| Глибина (пів-ходи) | Вузлів без A-B | Вузлів з A-B (ест.) |
|--------------------|---------------|----------------------|
| 2 | ~49 | ~15 |
| 4 | ~1 300 | ~200 |
| 5 | ~9 000 | ~600 |
| 7 | ~~600 000 | ~15 000 |

*Поле 6×7, k=4. Числа орієнтовні. Alpha-Beta відсікає ≈ 60–80% вузлів.*

---

## Представлення дошки

| Версія | Представлення | Доступ до клітини |
|--------|--------------|------------------|
| `kinariad.pl` | `board/5` — term + плаский список | O(R×C) |
| `server.pl` | Список рядків (`[[char]]`) | O(R+C) |
| `kinariad_tau.pl` | Flat atom + row-list in Prolog | O(R+C) |

Atom (рядок JavaScript) зберігає стан між ходами без глобального стану.

---

## Порівняння реалізацій

| Критерій | Prolog | Haskell | Python (іл.) |
|----------|--------|---------|--------------|
| Представлення дошки | Term `board/5`, плаский список | Record `Board`, `[[Cell]]` | `list[list]` |
| Оновлення стану | Без мутації (новий term) | Без мутації (новий record) | Мутація `board[r][c]` |
| MinMax | Клаузи + зворотній збій | Рекурсивні функції + `Maybe` | Явна рекурсія |
| Мультипризначенність | Вбудована | Відсутня | Відсутня |
| Генерація ходів | `findall` (декларативно) | List comprehension | `for` цикл |
| Швидкість MinMax | ~5–10× повільніше Python | ~2–3× повільніше Python | Базова |

### Обґрунтування CLP

CLP(FD) **не застосовано**. MinMax — це пошук у дереві гри, а не задача виконання обмежень (CSP). Змінні ходу не є FD-змінними — пошук ведеться через `findall`/`member`. CLP доцільний для задач типу розкладу або розподілу ресурсів, не для ігрового ШІ.

---

## Першоджерела та ступінь переробки

- **Russell S., Norvig P.** *Artificial Intelligence: A Modern Approach*, 4th ed., §5 — Adversarial Search and Games
- **SWI-Prolog documentation:** https://www.swi-prolog.org/pldoc/
- **Tau-Prolog:** http://tau-prolog.org/
- **SWI-Prolog HTTP server:** https://www.swi-prolog.org/pldoc/man?section=http
- **Render.com Docker deployment:** https://render.com/docs/docker

**Власний внесок:** ~100% оригінального коду. ChatGPT / Claude використовувались для:
- перевірки синтаксису SWI-Prolog HTTP предикатів (~15%)
- налагодження CORS preflight (~10%)
- генерації Haskell-версії для порівняння (~40% Haskell-коду)
